property has_mirror_component false;  // Is there a perfect specular component ?
property level_step  0xFFFF;          // How fast we use the recursivity quota, 0 means infinite recursion possible
property required_samples 0xFFFF;     // How many samples we want to sample incident light
parameter albedo vec4(1);             // Modulate albedo
parameter texture tex;
parameter leakyrelu_slope 0.01;

vec4 leakyrelu(vec4 v)
{
    return max(0.0, v) + leakyrelu_slope * min(0.0, v);
}

vec3 proj_vec_to_ortho(vec3 v, vec3 n)
{
    scalar cos_a = (v | n);
    vec3 proj = v - cos_a * n;
    return normalize(proj);
}

// This function is the BRDF itself, it must return a vec4 corresponding to the fraction of light reflected from i to e for each channel
// i is the incident vector (from the surface to the light source)
// e is the excident vector (from the surface to the camera)
// n is a vector normal to the surface
// diffuse is the 4 component color of the diffuse texture/color
// specular is the 4 component color of the specular texture/color
// shininess is the scalar value defining the width of specular lobes when applicable
vec4 brdf(vec3 $i,
          vec3 $e,
          vec3 $n,
          vec4 diffuse,
          vec4 specular,
          scalar shininess,
          scalar t,
          scalar duration,
          vec3 uv,
          scalar lod_bias)
{
    // half vector between incidence and excidence
    vec3 h = i/2 + e/2;

    // projection of excidence vector to orthogonal plane of normal vector = tangential vector
    vec3 e_proj_t = proj_vec_to_ortho(e, n);

    // projection of half vector to tangential plane
    vec3 h_proj_t = proj_vec_to_ortho(h, n);

    // projection of incidence vector to orthogonal plane to half vector
    vec3 i_proj_th = proj_vec_to_ortho(i, h);

    // BRDF parameters
    scalar cos_theta_h = (h | n);
    scalar cos_theta_d = (h | i);
    scalar cos_phi_h   = (e_proj_t  | h_proj_t);
    scalar cos_phi_d   = (i_proj_th | h_proj_t);

    // read parameters maps
    vec4 p = lookup3DLOD(tex, uv, lod_bias);
    p = leakyrelu(p);

    // formula
    scalar val = p.x * cos_theta_h + p.y * cos_theta_d + p.z * cos_phi_h + p.w * cos_phi_d;

    return vec4(val) * albedo;
}

// This function defines how much light the surface emits in direction e
// e is the excident vector (from the surface to the camera)
// n is a vector normal to the surface
// diffuse is the 4 component color of the diffuse texture/color
// specular is the 4 component color of the specular texture/color
// shininess is the scalar value defining the width of specular lobes when applicable
vec4 emission(vec3 $e, vec3 $n, vec4 emission, vec4 diffuse, vec4 specular, scalar shininess,
          scalar t,
          scalar duration,
          vec2 uv,
          scalar lod_bias)
{
  return emission * albedo;
}

