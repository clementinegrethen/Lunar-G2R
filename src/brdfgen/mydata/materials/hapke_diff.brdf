// Hapke BRDF (Moon model)
property has_mirror_component false;  // Is there a perfect specular component ?
property level_step  0xFFFF;          // How fast we use the recursivity quota, 0 means infinite recursion possible
property required_samples 0xFFFF;     // How many samples we want to sample incident light
parameter albedo vec4(1);             // Modulate albedo
parameter texture tex;
parameter leakyrelu_slope 0.01;

vec4 leakyrelu(vec4 v)
{
    return max(0.0, v) + leakyrelu_slope * min(0.0, v);
}

scalar H(scalar u, scalar w)
{
    return (0.5 + u) / (0.5 + u * w);
}

// This function is the BRDF itself, it must return a vec4 corresponding to the fraction of light reflected from i to e for each channel
// i is the incident vector (from the surface to the light source)
// e is the excident vector (from the surface to the camera)
// n is a vector normal to the surface
// diffuse is the 4 component color of the diffuse texture/color
// specular is the 4 component color of the specular texture/color
// shininess is the scalar value defining the width of specular lobes when applicable
vec4 brdf(vec3 $i,
          vec3 $e,
          vec3 $n,
          vec4 diffuse,
          vec4 specular,
          scalar shininess,
          scalar t,
          scalar duration,
          vec3 uv,
          scalar lod_bias)
{
    scalar u0 = (i | n);
    scalar u = (e | n);
    if (u0 < 0.0 || u < 0.0)
        return vec4(0);
    scalar cos_g = (i | e);
    scalar sin_g = sqrt(max(0.0, 1.0 - cos_g * cos_g));
    scalar tan_g = sin_g / cos_g;
    scalar g = atan2(sin_g, cos_g);
    scalar _1_cos_g = max(0.0, 1.0 - cos_g);
    scalar P = (4.0 * M_PI / 5.0) * ((sin_g + (M_PI - g) * cos_g) / M_PI + _1_cos_g * _1_cos_g / 10.0);

    // hapke parameters
    // based on the Moon bright and dark areas
    vec4 p = lookup3DLOD(tex, uv, lod_bias);
    p = leakyrelu(p);
    scalar h = p.x;
    scalar w = p.y;
    scalar B0 = p.z;

    scalar B;
    if (cos_g <= 0.0)
      B = 0;
    else
    {
      scalar exphtan = exp(-h / tan_g);
      B = B0 * (1.0 - tan_g / (2.0 * h) * (3.0 - exphtan) * (1.0 - exphtan));
    }
    scalar val = (((1 - w * w) / (4.0 * M_PI)) * (u0 / (u + u0)) * ((1.0 + B) * P + H(u0,w) * H(u,w) - 1.0));
    return vec4(val) * albedo;
}

// This function defines how much light the surface emits in direction e
// e is the excident vector (from the surface to the camera)
// n is a vector normal to the surface
// diffuse is the 4 component color of the diffuse texture/color
// specular is the 4 component color of the specular texture/color
// shininess is the scalar value defining the width of specular lobes when applicable
vec4 emission(vec3 $e, vec3 $n, vec4 emission, vec4 diffuse, vec4 specular, scalar shininess,
          scalar t,
          scalar duration,
          vec2 uv,
          scalar lod_bias)
{
  return emission * albedo;
}

