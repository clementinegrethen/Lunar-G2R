// BRDF template
property has_mirror_component false;  // Is there a perfect specular component ?
property level_step  0xFFFF;          // How fast we use the recursivity quota, 0 means infinite recursion possible
property required_samples 0xFFFF;     // How many samples we want to sample incident light
parameter texture tex;
parameter albedo vec4(1);

// This function is the BRDF itself, it must return a vec4 corresponding to the fraction of light reflected from i to e for each channel
// If this is varying through time, the expected value is the average over the given time frame
// i is the incident vector (from the surface to the light source)
// e is the excident vector (from the surface to the camera)
// n is a vector normal to the surface
// diffuse is the 4 component color of the diffuse texture/color
// specular is the 4 component color of the specular texture/color
// shininess is the scalar value defining the width of specular lobes when applicable
// t is the scalar value defining the (average) time (in s) with respect to the reference image acquisition time
// duration is the scalar value defining the duration (in s) covered by current sample (or ray)
// uv is the texture coordinate in normalized space [0,1] to be used when more textures/buffers are needed
// lod_bias is the LOD bias due to geometry (ray solid angle, incidence angle, surface texel density). Complete LOD = LOD_bias + 0.5 * log2(size(tex).x * size(tex).y)
//
// t and duration are optionnal (both or none should be present)
// uv and lod_bias are optionnal (both or none should be present). If present t and duration must be present too.
vec4 brdf(vec3 i,
          vec3 e,
          vec3 n,
          vec4 diffuse,
          vec4 specular,
          scalar shininess,
          scalar t,
          scalar duration,
          vec3 uv,
          scalar lod_bias)
{
    scalar in = (i | n);
    vec4 val = lookup3DLOD(tex, uv, lod_bias);
    return max(0.0, in) * val * M_1_PI * albedo;
}

// This function defines how much light the surface emits in direction e
// If this is varying through time, the expected value is the average over the given time frame
// e is the excident vector (from the surface to the camera)
// n is a vector normal to the surface
// diffuse is the 4 component color of the diffuse texture/color
// specular is the 4 component color of the specular texture/color
// shininess is the scalar value defining the width of specular lobes when applicable
// t is the scalar value defining the (average) time (in s) with respect to the reference image acquisition time
// duration is the scalar value defining the duration (in s) covered by current sample (or ray)
// uv is the texture coordinate in normalized space [0,1] to be used when more textures/buffers are needed
// lod_bias is the LOD bias due to geometry (ray solid angle, incidence angle, surface texel density). Complete LOD = LOD_bias + 0.5 * log2(size(tex).x * size(tex).y)
//
// t and duration are optionnal (both or none should be present)
// uv and lod_bias are optionnal (both or none should be present). If present t and duration must be present too.
vec4 emission(vec3 $e,
              vec3 $n,
              vec4 emission,
              vec4 diffuse,
              vec4 specular,
              scalar shininess,
              scalar t,
              scalar duration,
              vec2 uv,
              scalar lod_bias)
{
    return emission * albedo;
}
